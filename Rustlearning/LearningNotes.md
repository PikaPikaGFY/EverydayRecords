# Rust
-----
## cargo
> 包管理工具最重要的意义在于。任何用户拿到你的代码，都能运行起来，而不会因为各种包版本而焦头烂额
### Hello world!
作为一种现代化语言，rust吸收了多个语言的包管理优点，为大家提供了炒鸡大杀器`cargo`,下面是一个示例。 
```bash
$ cargo new hello_world
$ cd world_hello
```
上面的命令使用`cargo new`创建了一个新的项目，该项目的结构和配置文件都是由cargo生成的，意味着我们的项目被cargo所管理。
>ps：Rust项目主要分为两个类型，`bin`和`lib`，前者是可运行的项目，后者是一个依赖库项目
  
来看看这个优雅的项目结构：
```bash
$ tree
.
├── .git
├── .gitignore
├── Cargo.toml
└── src
    └── main.rs
```
连`git`都帮你创建了，实在贴心。  
在上述代码中，`cargo run`首先对项目进行编译，然后再运行，等同于运行了两个指令，下面我们手动试一下编译和运行项目：  
编译
```bash
$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
```
运行
```bash
$ .\target\debug\hello_world 
Hello, world!
```
在编译的时候，其实有两种编译模式、分别是`debug`和`release`,前者可以非常快地编译出程序来，而损失了一些性能，后者则会进行优化，编译高性能代码
  
当项目大了以后， `cargo run`和`cargo build`不可避免地会变慢，那么有没有更快的方式来验证代码的正确性呢？答案是：有！  
`cargo check`是一个非常快速的命令，仅仅是检查一下代码能否编译通过，而不会真的去编译，能节省非常多的时间。  

### Cargo.toml 和 Cargo.lock  
  
`Cargo.toml` 和 `Cargo.lock`是`cargo`的核心文件，它的所有活动均基于二者
  
- `Cargo.toml` 是 `cargo` 特有的项目数据描述文件，储存了项目所有的元配置信息  
- `Cargo.lock` 则是一个更加详细的项目依赖清单，一般不需要修改它  
  
我们接下来打开`Cargo.toml`
可以看到有两个段落：  
#### [package]
```
name = "hello_world"
version = "0.1.0"
edition = "2021"
```
其中这些配置也一目了然
#### [dependencies]
```
[Nothing yet]
```
那么如果要自定义项目依赖，我应该怎么写呢？
事实上，它可以有三种办法书写
```
[dependencies]
rand = "0.3"
hammer = { version = "0.5.0"}
color = { git = "https://github.com/bjz/color-rs" }
geometry = { path = "crates/geometry" }
```
- 前两者是**基于官方的Rust仓库`crates.io`，通过版本说明来描述依赖**
- 第三个是**基于项目源代码的git仓库地址，通过URL来描述**
- 第四个是**基于本地项目的绝对路径或者相对路径，通过类似于Unix模式的路径来书写**
  
## Var 变量
在 Rust 中，变量是需要手动设置可变性的，而且通常来讲，我们并不把以下内容称为“赋值”，
```rust
var = "hello world";
```
而把这个过程叫做“变量绑定”  
因为，这涉及到一个Rust的核心原则，那就是：“所有权”  
任何内存对象都是有主人的，而且一般情况下完全属于它的主人，绑定就是把这个对象绑定给一个变量，让这个变量成为他的主人【同时之前这个变量的主人就失去了变量的所有权】

- **变量的可变性**  
Rust的变量在默认情况下是不可变的，可以通过`mut`关键字让他变得可变
- **使用下划线使得Rust忽略未使用的变量**  
当你在设计原型时，难免会有一些草稿，可以通过下划线作为变量名的开头，来告诉他不要对这个未使用的变量"panic"

> 突然注意到的语法点：
> ```
>{} 用于打印实现了 Display trait 的类型的值，适合基本类型和常规输出。
>{:?} 用于打印实现了 Debug trait 的类型的值，适合调试复杂数据结构。
>对于基本类型如布尔值和数字，两者都可以使用，但 {:?} 更常用于调试。
>对于复合类型如元组、结构体和枚举，通常必须使用 {:?}。
> ```
- 变量和常量的区别
常量与不可变变变量不完全相同
有以下几个区别：
1. 常量不允许使用`mut`，因为常量不仅仅默认不可变，而且自始至终不可变，因为常量在编译完成后，已经确认了它的值，不再变化
2. 常量通常使用`const`,关键字而不是使用`let`关键字来声明，并且值的类型必须标注：  
例如:
```rust
const MAX_POINTS: u32 = 100_000;
```
(常量的声明通常使用全部大写，下划线分割单词，并在数字的字面量添加下划线)  
常量可以在任意作用域中声明，包括全局作用域，在声明的作用域内，常量在程序运行的整个过程中都有效  
- 变量遮蔽（Shadowing）
Rust允许**声明**相同的变量，在后面**声明**的变量会遮蔽掉前面**声明**的变量  
例如：  
```
// 字符串类型
let spaces = "   ";
// usize数值类型
let spaces = spaces.len();
```
注意！，不是这样：
```
let mut spaces = "   ";
spaces = spaces.len();
```
因为后者并不是**声明一个新变量**，所以会被编译器检测出来

## 基本类型
Rust每个值都有确切的数据类型，总的来说可以分为两类：基本类型与复合类型。  
- 数值类型：有符号整数 (i8, i16, i32, i64, isize)、 无符号整数 (u8, u16, u32, u64, usize) 、浮点数 (f32, f64)、以及有理数、复数
- 字符串：字符串字面量和字符串切片 &str
- 布尔类型：true 和 false
- 字符类型：表示单个 Unicode 字符，存储为 4 个字节
- 单元类型：即 () ，其唯一的值也是 ()